import test from "node:test";
import assert from "node:assert/strict";
import path from "node:path";
import { randomUUID } from "node:crypto";
import { tmpdir } from "node:os";
import { mkdtemp, writeFile, rm } from "node:fs/promises";

import { convertYamlToCypress } from "../src/generator/index.js";
import { registerCommand } from "../src/commands/registry.js";

async function createYamlSpec(contents) {
  const directory = await mkdtemp(path.join(tmpdir(), "cyyaml-generator-"));
  const filePath = path.join(directory, "spec.yaml");
  await writeFile(filePath, contents, "utf8");
  return { directory, filePath };
}

function stripSourceMap(code) {
  const [withoutMap] = code.split("\n//# sourceMappingURL");
  return withoutMap.trim();
}

test("convertYamlToCypress generates Cypress code from YAML specs", async (t) => {
  const yaml = `
name: Login Flow
description: Visit login
seedFile: ./seed.js
steps:
  - open: "/login"
  - log:
      message: "Logged in"
`;
  const { directory, filePath } = await createYamlSpec(yaml);

  t.after(async () => {
    await rm(directory, { recursive: true, force: true });
  });

  const { code, spec } = await convertYamlToCypress(filePath, {
    outputFileName: "login.cy.js",
  });

  const expected = `// This file was generated by cypress-yaml-plugin. Do not edit.
describe("Login Flow", () => {
  beforeEach(() => {
    cy.task("db:seed", "./seed.js");
  });
  it("Visit login", () => {
    cy.visit("/login");
    cy.log("Logged in");
  });
});`;

  assert.equal(stripSourceMap(code), expected);
  assert.equal(spec.steps[0].name, "open");
  assert.equal(spec.steps[1].name, "log");
});

test("convertYamlToCypress infers defaults for minimal specs", async (t) => {
  const yaml = `
name: Contact Spec
steps:
  - open: "/contact"
  - "Remind QA"
`;
  const { directory, filePath } = await createYamlSpec(yaml);

  t.after(async () => {
    await rm(directory, { recursive: true, force: true });
  });

  const { code } = await convertYamlToCypress(filePath);

  const expected = `// This file was generated by cypress-yaml-plugin. Do not edit.
describe("Contact Spec", () => {
  it("runs contact spec", () => {
    cy.visit("/contact");
    cy.log("Remind QA");
  });
});`;

  assert.equal(stripSourceMap(code), expected);
});

test("tapOn can force click elements with or without coordinates", async (t) => {
  const yaml = `
name: Force Tap Spec
steps:
  - tapOn:
      selector: '[data-cy="basic"]'
      force: true
  - tapOn:
      selector: '[data-cy="with-coordinates"]'
      xPercent: 25
      yPercent: 75
      force: true
`;
  const { directory, filePath } = await createYamlSpec(yaml);

  t.after(async () => {
    await rm(directory, { recursive: true, force: true });
  });

  const { code } = await convertYamlToCypress(filePath);
  const generated = stripSourceMap(code);

  assert.ok(
    generated.includes(".click({ force: true });"),
    "standard click should receive force option"
  );
  assert.ok(
    generated.includes("cy.wrap($el).click(x, y, { force: true });"),
    "coordinate click should receive force option"
  );
});

test("selectFile supports file paths and inline file data", async (t) => {
  const yaml = `
name: Select File Spec
steps:
  - selectFile:
      selector: '[data-cy="file-input"]'
      filePath: cypress/fixtures/users.csv
  - selectFile:
      dataCy: inline-upload
      contents: Inline file contents
      fileName: upload.txt
      mimeType: text/plain
      lastModified: 1700000000000
`;
  const { directory, filePath } = await createYamlSpec(yaml);

  t.after(async () => {
    await rm(directory, { recursive: true, force: true });
  });

  const { code } = await convertYamlToCypress(filePath);
  const generated = stripSourceMap(code);

  assert.ok(
    generated.includes('.selectFile("cypress/fixtures/users.csv");'),
    "filePath should be passed directly to selectFile"
  );
  assert.match(
    generated,
    /\.selectFile\(\{\s*contents: "Inline file contents",\s*fileName: "upload\.txt",\s*mimeType: "text\/plain",\s*lastModified: 1700000000000,\s*\}\);/s,
    "inline file data should be serialized into selectFile"
  );
});

test("locators can be scoped to parent selectors", async (t) => {
  const yaml = `
name: Nested Locator Spec
steps:
  - tapOn:
      dataCy: child
      parentCy: wrapper
  - assertContains:
      selector: 'button.save'
      parent: '.modal'
      text: "Save"
  - tapOn:
      text: "Button Label"
      parent: ".dialog"
`;
  const { directory, filePath } = await createYamlSpec(yaml);

  t.after(async () => {
    await rm(directory, { recursive: true, force: true });
  });

  const { code } = await convertYamlToCypress(filePath);
  const generated = stripSourceMap(code);

  assert.ok(
    generated.includes(
      "cy.get('[data-cy=\"wrapper\"]')\n      .find('[data-cy=\"child\"]')"
    ),
    "child locators should filter inside parentCy selectors"
  );
  assert.ok(
    generated.includes('cy.get(".modal").find("button.save")'),
    "CSS parents should scope downstream selectors"
  );
  assert.ok(
    generated.includes(
      'cy.get(".dialog")\n      .contains("Button Label", { matchCase: true })'
    ),
    "text-based locators should call contains on the parent scope"
  );
});

test("custom registered commands can be invoked from YAML specs", async (t) => {
  registerCommand(
    "testCommand",
    (value) => `cy.wrap(${JSON.stringify(value.message)});`
  );

  const yaml = `
name: Custom Registry Spec
steps:
  - testCommand:
      message: "first event"
`;
  const { directory, filePath } = await createYamlSpec(yaml);

  t.after(async () => {
    await rm(directory, { recursive: true, force: true });
  });

  const { code } = await convertYamlToCypress(filePath);

  const expected = `// This file was generated by cypress-yaml-plugin. Do not edit.
describe("Custom Registry Spec", () => {
  it("runs custom registry spec", () => {
    cy.wrap("first event");
  });
});`;

  assert.equal(stripSourceMap(code), expected);
});
