import MagicString, { Bundle } from "magic-string";
import prettier from "prettier";
import { loadYaml } from "../loader.js";
import { validateSpec } from "../validator.js";
import { resolveCommand } from "../commands/registry.js";
import { buildLocator } from "./locator.js";
import { YamlValidationError } from "../errors.js";

function indent(code, spaces = 2) {
  const pad = " ".repeat(spaces);
  return code
    .split("\n")
    .map((line) => (line.length ? `${pad}${line}` : line))
    .join("\n");
}

function buildHeader(spec) {
  const headerLines = [
    "// This file was generated by cypress-yaml-plugin. Do not edit.",
    `describe(${JSON.stringify(spec.name)}, () => {`,
  ];

  if (spec.seedFile) {
    headerLines.push("  beforeEach(() => {");
    headerLines.push(
      `    cy.task('db:seed', ${JSON.stringify(spec.seedFile)});`
    );
    headerLines.push("  });");
  }

  const testTitle = spec.description
    ? spec.description
    : `runs ${spec.name.toLowerCase()}`;

  headerLines.push(`  it(${JSON.stringify(testTitle)}, () => {`);
  return `${headerLines.join("\n")}\n`;
}

function buildFooter() {
  return "  });\n});\n";
}

function commandToCode(step, context) {
  const { name, value } = step;
  const command = resolveCommand(name);
  if (!command) {
    throw new YamlValidationError(`Command "${name}" is not registered.`, {
      filePath: context.filePath,
      line: step.line,
    });
  }

  const result = command.generate(value, {
    buildLocator,
    spec: context.spec,
    stepIndex: context.index,
  });

  const codeBlock = Array.isArray(result) ? result.join("\n") : result;
  return codeBlock.endsWith(";") ? codeBlock : `${codeBlock};`;
}

function buildStepSnippet(step, index, context) {
  const code = commandToCode(step, { ...context, index });
  const indented = `${indent(code, 4)}\n`;
  const { contents = "", stepMetadata = [] } = context;
  const metadata = stepMetadata[index];
  const slice =
    metadata?.range && metadata.range[0] < metadata.range[1]
      ? contents.slice(metadata.range[0], metadata.range[1])
      : "\n";
  const snippet = new MagicString(slice);
  snippet.overwrite(0, slice.length, indented);
  return snippet;
}

function buildBundle(spec, context) {
  const headerSnippet = new MagicString("\n");
  headerSnippet.overwrite(0, 1, buildHeader(spec));
  const bundle = new Bundle({ separator: "" });
  bundle.addSource({
    filename: context.filePath ?? spec.name,
    content: headerSnippet,
  });

  spec.steps.forEach((step, index) => {
    const snippet = buildStepSnippet(step, index, context);
    bundle.addSource({
      filename: context.filePath ?? spec.name,
      content: snippet,
    });
  });

  const footerSnippet = new MagicString("\n");
  footerSnippet.overwrite(0, 1, buildFooter());
  bundle.addSource({
    filename: context.filePath ?? spec.name,
    content: footerSnippet,
  });

  return bundle;
}

export async function generateTest(spec, context = {}) {
  const bundle = buildBundle(spec, context);
  const rawCode = bundle.toString();
  const formatted = await prettier.format(rawCode, { parser: "babel" });
  const sourcemap = bundle.generateMap({
    hires: true,
    includeContent: true,
    file: context.outputFileName,
  });

  const inlineMap = Buffer.from(JSON.stringify(sourcemap)).toString("base64");
  const withMap = `${formatted}\n//# sourceMappingURL=data:application/json;base64,${inlineMap}\n`;
  return { code: withMap, map: sourcemap };
}

export async function convertYamlToCypress(filePath, options = {}) {
  const notify = (stage, payload) => {
    if (typeof options.onStage === "function") {
      options.onStage(stage, payload);
    }
  };

  const loaded = await loadYaml(filePath);
  notify("parsed", { filePath: loaded.filePath });
  const validated = validateSpec(loaded.data, {
    filePath: loaded.filePath,
    stepMetadata: loaded.stepMetadata,
  });
  notify("validated", { spec: validated });

  const result = await generateTest(validated, {
    filePath: loaded.filePath,
    contents: loaded.contents,
    stepMetadata: loaded.stepMetadata,
    outputFileName: options.outputFileName,
    spec: validated,
  });
  notify("generated", { outputFile: options.outputFileName });
  return { ...result, spec: validated };
}
